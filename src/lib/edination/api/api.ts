/// <reference path="../types/custom.d.ts" />
// tslint:disable
/**
 * EdiNation API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'npm:url'
import * as isomorphicFetch from 'npm:isomorphic-fetch'
import { Configuration } from '../types/configuration.ts'

const BASE_PATH = 'https://api.edination.com/v2'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|'
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    this.configuration = configuration ?? new Configuration()
    this.basePath = configuration?.basePath ?? basePath
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  override name = 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface BHS
 */
export interface BHS {
  /**
   *
   * @type {string}
   * @memberof BHS
   */
  fieldSeparator01?: string
  /**
   *
   * @type {string}
   * @memberof BHS
   */
  batchEncodingCharacters02?: string
  /**
   *
   * @type {BatchSendingApplication}
   * @memberof BHS
   */
  batchSendingApplication03?: BatchSendingApplication
  /**
   *
   * @type {BatchSendingFacility}
   * @memberof BHS
   */
  batchSendingFacility04?: BatchSendingFacility
  /**
   *
   * @type {BatchReceivingApplication}
   * @memberof BHS
   */
  batchReceivingApplication05?: BatchReceivingApplication
  /**
   *
   * @type {BatchReceivingFacility}
   * @memberof BHS
   */
  batchReceivingFacility06?: BatchReceivingFacility
  /**
   *
   * @type {string}
   * @memberof BHS
   */
  batchCreationDateTime07?: string
  /**
   *
   * @type {string}
   * @memberof BHS
   */
  batchSecurity08?: string
  /**
   *
   * @type {string}
   * @memberof BHS
   */
  batchNameIDType09?: string
  /**
   *
   * @type {string}
   * @memberof BHS
   */
  batchComment10?: string
  /**
   *
   * @type {string}
   * @memberof BHS
   */
  batchControlID11?: string
  /**
   *
   * @type {string}
   * @memberof BHS
   */
  referenceBatchControlID12?: string
  /**
   *
   * @type {BatchSendingNetworkAddress}
   * @memberof BHS
   */
  batchSendingNetworkAddress13?: BatchSendingNetworkAddress
  /**
   *
   * @type {BatchReceivingNetworkAddress}
   * @memberof BHS
   */
  batchReceivingNetworkAddress14?: BatchReceivingNetworkAddress
}
/**
 *
 * @export
 * @interface BTS
 */
export interface BTS {
  /**
   *
   * @type {string}
   * @memberof BTS
   */
  batchMessageCount01?: string
  /**
   *
   * @type {string}
   * @memberof BTS
   */
  batchComment02?: string
  /**
   *
   * @type {Array<string>}
   * @memberof BTS
   */
  batchTotals03?: Array<string>
}
/**
 *
 * @export
 * @interface BatchReceivingApplication
 */
export interface BatchReceivingApplication {
  /**
   *
   * @type {string}
   * @memberof BatchReceivingApplication
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof BatchReceivingApplication
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof BatchReceivingApplication
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface BatchReceivingFacility
 */
export interface BatchReceivingFacility {
  /**
   *
   * @type {string}
   * @memberof BatchReceivingFacility
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof BatchReceivingFacility
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof BatchReceivingFacility
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface BatchReceivingNetworkAddress
 */
export interface BatchReceivingNetworkAddress {
  /**
   *
   * @type {string}
   * @memberof BatchReceivingNetworkAddress
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof BatchReceivingNetworkAddress
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof BatchReceivingNetworkAddress
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface BatchSendingApplication
 */
export interface BatchSendingApplication {
  /**
   *
   * @type {string}
   * @memberof BatchSendingApplication
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof BatchSendingApplication
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof BatchSendingApplication
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface BatchSendingFacility
 */
export interface BatchSendingFacility {
  /**
   *
   * @type {string}
   * @memberof BatchSendingFacility
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof BatchSendingFacility
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof BatchSendingFacility
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface BatchSendingNetworkAddress
 */
export interface BatchSendingNetworkAddress {
  /**
   *
   * @type {string}
   * @memberof BatchSendingNetworkAddress
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof BatchSendingNetworkAddress
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof BatchSendingNetworkAddress
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface EdiModel
 */
export interface EdiModel {
  /**
   *
   * @type {string}
   * @memberof EdiModel
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EdiModel
   */
  dateCreated?: string
  /**
   *
   * @type {Array<Link>}
   * @memberof EdiModel
   */
  links?: Array<Link>
}
/**
 *
 * @export
 * @interface EdifactGroup
 */
export interface EdifactGroup {
  /**
   *
   * @type {UNG}
   * @memberof EdifactGroup
   */
  UNG?: UNG
  /**
   *
   * @type {Array<any>}
   * @memberof EdifactGroup
   */
  transactions: Array<any>
  /**
   *
   * @type {Array<UNE>}
   * @memberof EdifactGroup
   */
  uNETrailers?: Array<UNE>
}
/**
 *
 * @export
 * @interface EdifactInterchange
 */
export interface EdifactInterchange {
  /**
   *
   * @type {UNA}
   * @memberof EdifactInterchange
   */
  UNA?: UNA
  /**
   *
   * @type {UNB}
   * @memberof EdifactInterchange
   */
  UNB: UNB
  /**
   *
   * @type {Array<EdifactGroup>}
   * @memberof EdifactInterchange
   */
  groups: Array<EdifactGroup>
  /**
   *
   * @type {Array<UNZ>}
   * @memberof EdifactInterchange
   */
  uNZTrailers?: Array<UNZ>
  /**
   *
   * @type {OperationResult}
   * @memberof EdifactInterchange
   */
  result?: OperationResult
}
/**
 *
 * @export
 * @interface EdifactReadBody
 */
export interface EdifactReadBody {
  /**
   * Upload File
   * @type {Blob}
   * @memberof EdifactReadBody
   */
  fileName: Blob
}
/**
 *
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
  /**
   *
   * @type {number}
   * @memberof ErrorDetails
   */
  code?: number
  /**
   *
   * @type {Array<string>}
   * @memberof ErrorDetails
   */
  details?: Array<string>
}
/**
 *
 * @export
 * @interface FHS
 */
export interface FHS {
  /**
   *
   * @type {string}
   * @memberof FHS
   */
  fieldSeparator01?: string
  /**
   *
   * @type {string}
   * @memberof FHS
   */
  fileEncodingCharacters02?: string
  /**
   *
   * @type {FileSendingApplication}
   * @memberof FHS
   */
  fileSendingApplication03?: FileSendingApplication
  /**
   *
   * @type {FileSendingFacility}
   * @memberof FHS
   */
  fileSendingFacility04?: FileSendingFacility
  /**
   *
   * @type {FileReceivingApplication}
   * @memberof FHS
   */
  fileReceivingApplication05?: FileReceivingApplication
  /**
   *
   * @type {FileReceivingFacility}
   * @memberof FHS
   */
  fileReceivingFacility06?: FileReceivingFacility
  /**
   *
   * @type {string}
   * @memberof FHS
   */
  fileCreationDateTime07?: string
  /**
   *
   * @type {string}
   * @memberof FHS
   */
  fileSecurity08?: string
  /**
   *
   * @type {string}
   * @memberof FHS
   */
  fileNameID09?: string
  /**
   *
   * @type {string}
   * @memberof FHS
   */
  fileHeaderComment10?: string
  /**
   *
   * @type {string}
   * @memberof FHS
   */
  fileControlID11?: string
  /**
   *
   * @type {string}
   * @memberof FHS
   */
  referenceFileControlID12?: string
  /**
   *
   * @type {FileSendingNetworkAddress}
   * @memberof FHS
   */
  fileSendingNetworkAddress13?: FileSendingNetworkAddress
  /**
   *
   * @type {FileReceivingNetworkAddress}
   * @memberof FHS
   */
  fileReceivingNetworkAddress14?: FileReceivingNetworkAddress
}
/**
 *
 * @export
 * @interface FTS
 */
export interface FTS {
  /**
   *
   * @type {string}
   * @memberof FTS
   */
  fileBatchCount01?: string
  /**
   *
   * @type {string}
   * @memberof FTS
   */
  fileTrailerComment02?: string
}
/**
 *
 * @export
 * @interface FileReceivingApplication
 */
export interface FileReceivingApplication {
  /**
   *
   * @type {string}
   * @memberof FileReceivingApplication
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof FileReceivingApplication
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof FileReceivingApplication
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface FileReceivingFacility
 */
export interface FileReceivingFacility {
  /**
   *
   * @type {string}
   * @memberof FileReceivingFacility
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof FileReceivingFacility
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof FileReceivingFacility
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface FileReceivingNetworkAddress
 */
export interface FileReceivingNetworkAddress {
  /**
   *
   * @type {string}
   * @memberof FileReceivingNetworkAddress
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof FileReceivingNetworkAddress
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof FileReceivingNetworkAddress
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface FileSendingApplication
 */
export interface FileSendingApplication {
  /**
   *
   * @type {string}
   * @memberof FileSendingApplication
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof FileSendingApplication
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof FileSendingApplication
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface FileSendingFacility
 */
export interface FileSendingFacility {
  /**
   *
   * @type {string}
   * @memberof FileSendingFacility
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof FileSendingFacility
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof FileSendingFacility
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface FileSendingNetworkAddress
 */
export interface FileSendingNetworkAddress {
  /**
   *
   * @type {string}
   * @memberof FileSendingNetworkAddress
   */
  namespaceID01?: string
  /**
   *
   * @type {string}
   * @memberof FileSendingNetworkAddress
   */
  universalID02?: string
  /**
   *
   * @type {string}
   * @memberof FileSendingNetworkAddress
   */
  universalIDType03?: string
}
/**
 *
 * @export
 * @interface FlatMessage
 */
export interface FlatMessage {
  /**
   *
   * @type {string}
   * @memberof FlatMessage
   */
  id?: string
  /**
   *
   * @type {any}
   * @memberof FlatMessage
   */
  value?: any
  /**
   *
   * @type {OperationResult}
   * @memberof FlatMessage
   */
  result?: OperationResult
}
/**
 *
 * @export
 * @interface GE
 */
export interface GE {
  /**
   *
   * @type {string}
   * @memberof GE
   */
  numberOfIncludedSets1?: string
  /**
   *
   * @type {string}
   * @memberof GE
   */
  groupControlNumber2?: string
}
/**
 *
 * @export
 * @interface GS
 */
export interface GS {
  /**
   *
   * @type {string}
   * @memberof GS
   */
  codeIdentifyingInformationType1?: string
  /**
   *
   * @type {string}
   * @memberof GS
   */
  senderIDCode2?: string
  /**
   *
   * @type {string}
   * @memberof GS
   */
  receiverIDCode3?: string
  /**
   *
   * @type {string}
   * @memberof GS
   */
  date4?: string
  /**
   *
   * @type {string}
   * @memberof GS
   */
  time5?: string
  /**
   *
   * @type {string}
   * @memberof GS
   */
  groupControlNumber6?: string
  /**
   *
   * @type {string}
   * @memberof GS
   */
  transactionTypeCode7?: string
  /**
   *
   * @type {string}
   * @memberof GS
   */
  versionAndRelease8?: string
}
/**
 *
 * @export
 * @interface Hl7Group
 */
export interface Hl7Group {
  /**
   *
   * @type {BHS}
   * @memberof Hl7Group
   */
  BHS?: BHS
  /**
   *
   * @type {Array<any>}
   * @memberof Hl7Group
   */
  transactions: Array<any>
  /**
   *
   * @type {Array<BTS>}
   * @memberof Hl7Group
   */
  bTSTrailers?: Array<BTS>
}
/**
 *
 * @export
 * @interface Hl7Interchange
 */
export interface Hl7Interchange {
  /**
   *
   * @type {FHS}
   * @memberof Hl7Interchange
   */
  FHS?: FHS
  /**
   *
   * @type {Array<Hl7Group>}
   * @memberof Hl7Interchange
   */
  groups: Array<Hl7Group>
  /**
   *
   * @type {Array<FTS>}
   * @memberof Hl7Interchange
   */
  fTSTrailers?: Array<FTS>
  /**
   *
   * @type {OperationResult}
   * @memberof Hl7Interchange
   */
  result?: OperationResult
}
/**
 *
 * @export
 * @interface Hl7ReadBody
 */
export interface Hl7ReadBody {
  /**
   * Upload File
   * @type {Blob}
   * @memberof Hl7ReadBody
   */
  fileName: Blob
}
/**
 *
 * @export
 * @interface IEA
 */
export interface IEA {
  /**
   *
   * @type {string}
   * @memberof IEA
   */
  numberOfIncludedGroups1?: string
  /**
   *
   * @type {string}
   * @memberof IEA
   */
  interchangeControlNumber2?: string
}
/**
 *
 * @export
 * @interface ISA
 */
export interface ISA {
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  authorizationInformationQualifier1?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  authorizationInformation2?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  securityInformationQualifier3?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  securityInformation4?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  senderIDQualifier5?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  interchangeSenderID6?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  receiverIDQualifier7?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  interchangeReceiverID8?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  interchangeDate9?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  interchangeTime10?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  interchangeControlStandardsIdentifier11?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  interchangeControlVersionNumber12?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  interchangeControlNumber13?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  acknowledgementRequested14?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  usageIndicator15?: string
  /**
   *
   * @type {string}
   * @memberof ISA
   */
  componentElementSeparator16?: string
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {string}
   * @memberof Link
   */
  rel?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  href?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  action?: string
}
/**
 *
 * @export
 * @interface ModelsBody
 */
export interface ModelsBody {
  /**
   * Upload File
   * @type {Blob}
   * @memberof ModelsBody
   */
  fileName: Blob
}
/**
 *
 * @export
 * @interface NcpdpReadBody
 */
export interface NcpdpReadBody {
  /**
   * Upload File
   * @type {Blob}
   * @memberof NcpdpReadBody
   */
  fileName: Blob
}
/**
 *
 * @export
 * @interface NcpdpTransmission
 */
export interface NcpdpTransmission {
  /**
   *
   * @type {TransmissionHeader}
   * @memberof NcpdpTransmission
   */
  transmissionHeader?: TransmissionHeader
  /**
   *
   * @type {Array<any>}
   * @memberof NcpdpTransmission
   */
  transactions: Array<any>
  /**
   *
   * @type {TransmissionTrailer}
   * @memberof NcpdpTransmission
   */
  transmissionTrailer?: TransmissionTrailer
  /**
   *
   * @type {OperationResult}
   * @memberof NcpdpTransmission
   */
  result?: OperationResult
}
/**
 *
 * @export
 * @interface OperationDetail
 */
export interface OperationDetail {
  /**
   *
   * @type {number}
   * @memberof OperationDetail
   */
  index?: number
  /**
   *
   * @type {number}
   * @memberof OperationDetail
   */
  transactionIndex?: number
  /**
   *
   * @type {string}
   * @memberof OperationDetail
   */
  transactionRef?: string
  /**
   *
   * @type {string}
   * @memberof OperationDetail
   */
  specRef?: string
  /**
   *
   * @type {string}
   * @memberof OperationDetail
   */
  segmentId?: string
  /**
   *
   * @type {string}
   * @memberof OperationDetail
   */
  dataElementId?: string
  /**
   *
   * @type {number}
   * @memberof OperationDetail
   */
  dataElementIndex?: number
  /**
   *
   * @type {number}
   * @memberof OperationDetail
   */
  compositeIndex?: number
  /**
   *
   * @type {number}
   * @memberof OperationDetail
   */
  repIndex?: number
  /**
   *
   * @type {string}
   * @memberof OperationDetail
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof OperationDetail
   */
  Message?: string
  /**
   *
   * @type {string}
   * @memberof OperationDetail
   */
  status?: string
}
/**
 *
 * @export
 * @interface OperationResult
 */
export interface OperationResult {
  /**
   *
   * @type {number}
   * @memberof OperationResult
   */
  LastIndex?: number
  /**
   *
   * @type {Array<OperationDetail>}
   * @memberof OperationResult
   */
  Details?: Array<OperationDetail>
  /**
   *
   * @type {string}
   * @memberof OperationResult
   */
  Status?: string
}
/**
 *
 * @export
 * @interface S001
 */
export interface S001 {
  /**
   *
   * @type {string}
   * @memberof S001
   */
  syntaxIdentifier1?: string
  /**
   *
   * @type {string}
   * @memberof S001
   */
  syntaxVersionNumber2?: string
  /**
   *
   * @type {string}
   * @memberof S001
   */
  serviceCodeListDirectoryVersionNumber3?: string
  /**
   *
   * @type {string}
   * @memberof S001
   */
  characterEncoding4?: string
}
/**
 *
 * @export
 * @interface S002
 */
export interface S002 {
  /**
   *
   * @type {string}
   * @memberof S002
   */
  interchangeSenderIdentification1?: string
  /**
   *
   * @type {string}
   * @memberof S002
   */
  identificationCodeQualifier2?: string
  /**
   *
   * @type {string}
   * @memberof S002
   */
  interchangeSenderInternalIdentification3?: string
  /**
   *
   * @type {string}
   * @memberof S002
   */
  interchangeSenderInternalSubIdentification4?: string
}
/**
 *
 * @export
 * @interface S003
 */
export interface S003 {
  /**
   *
   * @type {string}
   * @memberof S003
   */
  interchangeRecipientIdentification1?: string
  /**
   *
   * @type {string}
   * @memberof S003
   */
  identificationCodeQualifier2?: string
  /**
   *
   * @type {string}
   * @memberof S003
   */
  interchangeRecipientInternalIdentification3?: string
  /**
   *
   * @type {string}
   * @memberof S003
   */
  interchangeRecipientInternalSubIdentification4?: string
}
/**
 *
 * @export
 * @interface S004
 */
export interface S004 {
  /**
   *
   * @type {string}
   * @memberof S004
   */
  date1?: string
  /**
   *
   * @type {string}
   * @memberof S004
   */
  time2?: string
}
/**
 *
 * @export
 * @interface S005
 */
export interface S005 {
  /**
   *
   * @type {string}
   * @memberof S005
   */
  recipientReferencePassword1?: string
  /**
   *
   * @type {string}
   * @memberof S005
   */
  recipientReferencePasswordQualifier2?: string
}
/**
 *
 * @export
 * @interface S006
 */
export interface S006 {
  /**
   *
   * @type {string}
   * @memberof S006
   */
  applicationSenderIdentification1?: string
  /**
   *
   * @type {string}
   * @memberof S006
   */
  identificationCodeQualifier2?: string
}
/**
 *
 * @export
 * @interface S007
 */
export interface S007 {
  /**
   *
   * @type {string}
   * @memberof S007
   */
  applicationRecipientIdentification1?: string
  /**
   *
   * @type {string}
   * @memberof S007
   */
  identificationCodeQualifier2?: string
}
/**
 *
 * @export
 * @interface S008
 */
export interface S008 {
  /**
   *
   * @type {string}
   * @memberof S008
   */
  messageVersionNumber1?: string
  /**
   *
   * @type {string}
   * @memberof S008
   */
  messageReleaseNumber2?: string
  /**
   *
   * @type {string}
   * @memberof S008
   */
  associationAssignedCode3?: string
}
/**
 *
 * @export
 * @interface TA1
 */
export interface TA1 {
  /**
   *
   * @type {string}
   * @memberof TA1
   */
  interchangeControlNumber1?: string
  /**
   *
   * @type {string}
   * @memberof TA1
   */
  interchangeDate2?: string
  /**
   *
   * @type {string}
   * @memberof TA1
   */
  interchangeTime3?: string
  /**
   *
   * @type {string}
   * @memberof TA1
   */
  interchangeAcknowledgmentCode4?: string
  /**
   *
   * @type {string}
   * @memberof TA1
   */
  interchangeNoteCode5?: string
}
/**
 *
 * @export
 * @interface TransmissionHeader
 */
export interface TransmissionHeader {
  /**
   *
   * @type {string}
   * @memberof TransmissionHeader
   */
  transmissionType1?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionHeader
   */
  senderId2?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionHeader
   */
  batchNumber3?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionHeader
   */
  creationDate4?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionHeader
   */
  creationTime5?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionHeader
   */
  fileType6?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionHeader
   */
  version7?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionHeader
   */
  receiverId8?: string
}
/**
 *
 * @export
 * @interface TransmissionTrailer
 */
export interface TransmissionTrailer {
  /**
   *
   * @type {string}
   * @memberof TransmissionTrailer
   */
  batchNumber1?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionTrailer
   */
  recordCount2?: string
  /**
   *
   * @type {string}
   * @memberof TransmissionTrailer
   */
  message3?: string
}
/**
 *
 * @export
 * @interface UNA
 */
export interface UNA {
  /**
   *
   * @type {string}
   * @memberof UNA
   */
  componentDataElement?: string
  /**
   *
   * @type {string}
   * @memberof UNA
   */
  dataElement?: string
  /**
   *
   * @type {string}
   * @memberof UNA
   */
  decimalNotation?: string
  /**
   *
   * @type {string}
   * @memberof UNA
   */
  releaseIndicator?: string
  /**
   *
   * @type {string}
   * @memberof UNA
   */
  reserved?: string
  /**
   *
   * @type {string}
   * @memberof UNA
   */
  segment?: string
}
/**
 *
 * @export
 * @interface UNB
 */
export interface UNB {
  /**
   *
   * @type {S001}
   * @memberof UNB
   */
  sYNTAXIDENTIFIER1?: S001
  /**
   *
   * @type {S002}
   * @memberof UNB
   */
  iNTERCHANGESENDER2?: S002
  /**
   *
   * @type {S003}
   * @memberof UNB
   */
  iNTERCHANGERECIPIENT3?: S003
  /**
   *
   * @type {S004}
   * @memberof UNB
   */
  dATEANDTIMEOFPREPARATION4?: S004
  /**
   *
   * @type {string}
   * @memberof UNB
   */
  interchangeControlReference5?: string
  /**
   *
   * @type {S005}
   * @memberof UNB
   */
  rECIPIENTSREFERENCEPASSWORDDETAILS6?: S005
  /**
   *
   * @type {string}
   * @memberof UNB
   */
  applicationReference7?: string
  /**
   *
   * @type {string}
   * @memberof UNB
   */
  processingPriorityCode8?: string
  /**
   *
   * @type {string}
   * @memberof UNB
   */
  acknowledgementRequest9?: string
  /**
   *
   * @type {string}
   * @memberof UNB
   */
  interchangeAgreementIdentifier10?: string
  /**
   *
   * @type {string}
   * @memberof UNB
   */
  testIndicator11?: string
}
/**
 *
 * @export
 * @interface UNE
 */
export interface UNE {
  /**
   *
   * @type {string}
   * @memberof UNE
   */
  groupControlCount1?: string
  /**
   *
   * @type {string}
   * @memberof UNE
   */
  groupReferenceNumber2?: string
}
/**
 *
 * @export
 * @interface UNG
 */
export interface UNG {
  /**
   *
   * @type {string}
   * @memberof UNG
   */
  messageGroupIdentification1?: string
  /**
   *
   * @type {S006}
   * @memberof UNG
   */
  aPPLICATIONSENDERIDENTIFICATION2?: S006
  /**
   *
   * @type {S007}
   * @memberof UNG
   */
  aPPLICATIONRECIPIENTIDENTIFICATION3?: S007
  /**
   *
   * @type {S004}
   * @memberof UNG
   */
  dATEANDTIMEOFPREPARATION4?: S004
  /**
   *
   * @type {string}
   * @memberof UNG
   */
  groupReferenceNumber5?: string
  /**
   *
   * @type {string}
   * @memberof UNG
   */
  controllingAgency6?: string
  /**
   *
   * @type {S008}
   * @memberof UNG
   */
  mESSAGEVERSION7?: S008
  /**
   *
   * @type {string}
   * @memberof UNG
   */
  applicationPassword8?: string
}
/**
 *
 * @export
 * @interface UNZ
 */
export interface UNZ {
  /**
   *
   * @type {string}
   * @memberof UNZ
   */
  interchangeControlCount1?: string
  /**
   *
   * @type {string}
   * @memberof UNZ
   */
  interchangeControlReference2?: string
}
/**
 *
 * @export
 * @interface VdaReadBody
 */
export interface VdaReadBody {
  /**
   * Upload File
   * @type {Blob}
   * @memberof VdaReadBody
   */
  fileName: Blob
}
/**
 *
 * @export
 * @interface X12Group
 */
export interface X12Group {
  /**
   *
   * @type {GS}
   * @memberof X12Group
   */
  GS: GS
  /**
   *
   * @type {Array<any>}
   * @memberof X12Group
   */
  transactions: Array<any>
  /**
   *
   * @type {Array<GE>}
   * @memberof X12Group
   */
  gETrailers?: Array<GE>
}
/**
 *
 * @export
 * @interface X12Interchange
 */
export interface X12Interchange {
  /**
   *
   * @type {string}
   * @memberof X12Interchange
   */
  segmentDelimiter: string
  /**
   *
   * @type {string}
   * @memberof X12Interchange
   */
  dataElementDelimiter: string
  /**
   *
   * @type {ISA}
   * @memberof X12Interchange
   */
  ISA: ISA
  /**
   *
   * @type {TA1}
   * @memberof X12Interchange
   */
  tA1?: TA1
  /**
   *
   * @type {Array<X12Group>}
   * @memberof X12Interchange
   */
  groups: Array<X12Group>
  /**
   *
   * @type {Array<IEA>}
   * @memberof X12Interchange
   */
  iEATrailers?: Array<IEA>
  /**
   *
   * @type {OperationResult}
   * @memberof X12Interchange
   */
  Result?: OperationResult
}
/**
 *
 * @export
 * @interface X12ReadBody
 */
export interface X12ReadBody {
  /**
   * Upload File
   * @type {Blob}
   * @memberof X12ReadBody
   */
  fileName: Blob
}
/**
 * EdiModelApi - fetch parameter creator
 * @export
 */
export const EdiModelApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Retrieve the names of all EDI models
     * @param {boolean} [system] Whether to retrieve EdiNation&#x27;s or custom uploaded models.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsGet(system?: boolean, options: any = {}): FetchArgs {
      const localVarPath = `/models`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (system !== undefined) {
        localVarQueryParameter['system'] = system
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Delete an EDI model
     * @param {string} id The model name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsIdDelete(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling modelsIdDelete.'
        )
      }
      const localVarPath = `/models/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Retrieve an EDI model
     * @param {string} id The model name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsIdGet(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling modelsIdGet.'
        )
      }
      const localVarPath = `/models/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Upload EDI models in either SEF or OpenEDI format
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsPost(body?: Object, fileName?: Blob, options: any = {}): FetchArgs {
      const localVarPath = `/models`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (fileName !== undefined) {
        localVarFormParams.set('fileName', fileName as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * EdiModelApi - functional programming interface
 * @export
 */
export const EdiModelApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve the names of all EDI models
     * @param {boolean} [system] Whether to retrieve EdiNation&#x27;s or custom uploaded models.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsGet(
      system?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EdiModel>> {
      const localVarFetchArgs = EdiModelApiFetchParamCreator(
        configuration
      ).modelsGet(system, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Delete an EDI model
     * @param {string} id The model name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsIdDelete(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = EdiModelApiFetchParamCreator(
        configuration
      ).modelsIdDelete(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Retrieve an EDI model
     * @param {string} id The model name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsIdGet(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = EdiModelApiFetchParamCreator(
        configuration
      ).modelsIdGet(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Upload EDI models in either SEF or OpenEDI format
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsPost(
      body?: Object,
      fileName?: Blob,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = EdiModelApiFetchParamCreator(
        configuration
      ).modelsPost(body, fileName, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * EdiModelApi - factory interface
 * @export
 */
export const EdiModelApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Retrieve the names of all EDI models
     * @param {boolean} [system] Whether to retrieve EdiNation&#x27;s or custom uploaded models.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsGet(system?: boolean, options?: any) {
      return EdiModelApiFp(configuration).modelsGet(system, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Delete an EDI model
     * @param {string} id The model name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsIdDelete(id: string, options?: any) {
      return EdiModelApiFp(configuration).modelsIdDelete(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Retrieve an EDI model
     * @param {string} id The model name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsIdGet(id: string, options?: any) {
      return EdiModelApiFp(configuration).modelsIdGet(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Upload EDI models in either SEF or OpenEDI format
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modelsPost(body?: Object, fileName?: Blob, options?: any) {
      return EdiModelApiFp(configuration).modelsPost(
        body,
        fileName,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * EdiModelApi - object-oriented interface
 * @export
 * @class EdiModelApi
 * @extends {BaseAPI}
 */
export class EdiModelApi extends BaseAPI {
  /**
   *
   * @summary Retrieve the names of all EDI models
   * @param {boolean} [system] Whether to retrieve EdiNation&#x27;s or custom uploaded models.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EdiModelApi
   */
  public modelsGet(system?: boolean, options?: any) {
    return EdiModelApiFp(this.configuration).modelsGet(system, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Delete an EDI model
   * @param {string} id The model name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EdiModelApi
   */
  public modelsIdDelete(id: string, options?: any) {
    return EdiModelApiFp(this.configuration).modelsIdDelete(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Retrieve an EDI model
   * @param {string} id The model name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EdiModelApi
   */
  public modelsIdGet(id: string, options?: any) {
    return EdiModelApiFp(this.configuration).modelsIdGet(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Upload EDI models in either SEF or OpenEDI format
   * @param {Object} [body]
   * @param {Blob} [fileName]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EdiModelApi
   */
  public modelsPost(body?: Object, fileName?: Blob, options?: any) {
    return EdiModelApiFp(this.configuration).modelsPost(
      body,
      fileName,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * EdifactApi - fetch parameter creator
 * @export
 */
export const EdifactApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Generate EDIFACT acknowledments
     * @param {EdifactInterchange} [body] The EdifactInterchange object to acknowledge.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than UNOA and UNOB, populate this filed with all of the allowed symbols, url-escaped. All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The supported syntax sets are UNOA and UNOB. The validator infers the correct syntax set from EdifactInterchange.UNB.SYNTAXIDENTIFIER_1.SyntaxIdentifier_1. The symbols added to this field will override the corresponding sets in both UNOA and UNOB.
     * @param {boolean} [detectDuplicates] If you need to detect duplicates as in functional groups or transactions with the same reference number, set this flag to true. The default is false.
     * @param {number} [tranRefNumber] The default is 1. Set this to whatever the CONTRL UNH.MessageReferenceNumber_01 needs to be.
     * @param {number} [interchangeRefNumber] The default is 1. Set this to whatever the CONTRL EdifactInterchange.UNB.InterchangeControlReference_5 needs to be.
     * @param {boolean} [ackForValidTrans] The default is false. Set this to true if you need UCM loops included for all valid transaction as well. By default UCM loops are generated only for invalid transactions.
     * @param {boolean} [batchAcks] The default is true. Set this to false if you need to generate separate EdifactInterchange for each acknowledgment. By default all acknowledgments are batched in the same EdifactInterchange.
     * @param {string} [technicalAck] The default technical acknowledgment CONTRL is generated according to EdifactInterchange.UNB.AcknowledgementRequest_9. You can either enforce it to always generate technical CONTRLs or supress it to never generate any technical CONTRLs. This will override the flag in EdifactInterchange.UNB.AcknowledgementRequest_9.              The available values are: default, enforce, suppress.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactAckPost(
      body?: EdifactInterchange,
      syntaxSet?: string,
      detectDuplicates?: boolean,
      tranRefNumber?: number,
      interchangeRefNumber?: number,
      ackForValidTrans?: boolean,
      batchAcks?: boolean,
      technicalAck?: string,
      eancomS3?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/edifact/ack`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (syntaxSet !== undefined) {
        localVarQueryParameter['syntaxSet'] = syntaxSet
      }

      if (detectDuplicates !== undefined) {
        localVarQueryParameter['detectDuplicates'] = detectDuplicates
      }

      if (tranRefNumber !== undefined) {
        localVarQueryParameter['tranRefNumber'] = tranRefNumber
      }

      if (interchangeRefNumber !== undefined) {
        localVarQueryParameter['interchangeRefNumber'] = interchangeRefNumber
      }

      if (ackForValidTrans !== undefined) {
        localVarQueryParameter['ackForValidTrans'] = ackForValidTrans
      }

      if (batchAcks !== undefined) {
        localVarQueryParameter['batchAcks'] = batchAcks
      }

      if (technicalAck !== undefined) {
        localVarQueryParameter['technicalAck'] = technicalAck
      }

      if (eancomS3 !== undefined) {
        localVarQueryParameter['eancomS3'] = eancomS3
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'EdifactInterchange' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Convert EDIFACT files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be translated and validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      eancomS3?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/edifact/read`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (ignoreNullValues !== undefined) {
        localVarQueryParameter['ignoreNullValues'] = ignoreNullValues
      }

      if (continueOnError !== undefined) {
        localVarQueryParameter['continueOnError'] = continueOnError
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (model !== undefined) {
        localVarQueryParameter['model'] = model
      }

      if (eancomS3 !== undefined) {
        localVarQueryParameter['eancomS3'] = eancomS3
      }

      if (fileName !== undefined) {
        localVarFormParams.set('fileName', fileName as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Validate EDIFACT messages
     * @param {EdifactInterchange} [body] The EdifactInterchange object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than UNOA and UNOB, populate this filed with all of the allowed symbols, url-escaped.              All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The supported syntax sets are UNOA and UNOB. The validator infers the correct syntax set from EdifactInterchange.UNB.SYNTAXIDENTIFIER_1.SyntaxIdentifier_1. The symbols added to this field will override the corresponding sets in both UNOA and UNOB.
     * @param {boolean} [skipTrailer] You are allowed to validate an EdifactInterchange with missing interchange, functional group or transaction trailers (UNZ, UNE, UNT). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the EdifactInterchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {string} [decimalPoint] This could be either point . (default) or comma ,.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactValidatePost(
      body?: EdifactInterchange,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      decimalPoint?: string,
      eancomS3?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/edifact/validate`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (syntaxSet !== undefined) {
        localVarQueryParameter['syntaxSet'] = syntaxSet
      }

      if (skipTrailer !== undefined) {
        localVarQueryParameter['skipTrailer'] = skipTrailer
      }

      if (structureOnly !== undefined) {
        localVarQueryParameter['structureOnly'] = structureOnly
      }

      if (decimalPoint !== undefined) {
        localVarQueryParameter['decimalPoint'] = decimalPoint
      }

      if (eancomS3 !== undefined) {
        localVarQueryParameter['eancomS3'] = eancomS3
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'EdifactInterchange' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Convert JSON to EDIFACT files
     * @param {EdifactInterchange} [body] The EdifactInterchange object to translate to raw EDIFACT.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {boolean} [sameRepetionAndDataElement] Sometimes the same delimiter is used to denote data element separator and repetition separator as in IATA transactions. By default, this is false.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be translated and validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactWritePost(
      body?: EdifactInterchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      sameRepetionAndDataElement?: boolean,
      eancomS3?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/edifact/write`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (preserveWhitespace !== undefined) {
        localVarQueryParameter['preserveWhitespace'] = preserveWhitespace
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (postfix !== undefined) {
        localVarQueryParameter['postfix'] = postfix
      }

      if (sameRepetionAndDataElement !== undefined) {
        localVarQueryParameter['sameRepetionAndDataElement'] =
          sameRepetionAndDataElement
      }

      if (eancomS3 !== undefined) {
        localVarQueryParameter['eancomS3'] = eancomS3
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'EdifactInterchange' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * EdifactApi - functional programming interface
 * @export
 */
export const EdifactApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Generate EDIFACT acknowledments
     * @param {EdifactInterchange} [body] The EdifactInterchange object to acknowledge.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than UNOA and UNOB, populate this filed with all of the allowed symbols, url-escaped. All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The supported syntax sets are UNOA and UNOB. The validator infers the correct syntax set from EdifactInterchange.UNB.SYNTAXIDENTIFIER_1.SyntaxIdentifier_1. The symbols added to this field will override the corresponding sets in both UNOA and UNOB.
     * @param {boolean} [detectDuplicates] If you need to detect duplicates as in functional groups or transactions with the same reference number, set this flag to true. The default is false.
     * @param {number} [tranRefNumber] The default is 1. Set this to whatever the CONTRL UNH.MessageReferenceNumber_01 needs to be.
     * @param {number} [interchangeRefNumber] The default is 1. Set this to whatever the CONTRL EdifactInterchange.UNB.InterchangeControlReference_5 needs to be.
     * @param {boolean} [ackForValidTrans] The default is false. Set this to true if you need UCM loops included for all valid transaction as well. By default UCM loops are generated only for invalid transactions.
     * @param {boolean} [batchAcks] The default is true. Set this to false if you need to generate separate EdifactInterchange for each acknowledgment. By default all acknowledgments are batched in the same EdifactInterchange.
     * @param {string} [technicalAck] The default technical acknowledgment CONTRL is generated according to EdifactInterchange.UNB.AcknowledgementRequest_9. You can either enforce it to always generate technical CONTRLs or supress it to never generate any technical CONTRLs. This will override the flag in EdifactInterchange.UNB.AcknowledgementRequest_9.              The available values are: default, enforce, suppress.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactAckPost(
      body?: EdifactInterchange,
      syntaxSet?: string,
      detectDuplicates?: boolean,
      tranRefNumber?: number,
      interchangeRefNumber?: number,
      ackForValidTrans?: boolean,
      batchAcks?: boolean,
      technicalAck?: string,
      eancomS3?: boolean,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<EdifactInterchange>> {
      const localVarFetchArgs = EdifactApiFetchParamCreator(
        configuration
      ).edifactAckPost(
        body,
        syntaxSet,
        detectDuplicates,
        tranRefNumber,
        interchangeRefNumber,
        ackForValidTrans,
        batchAcks,
        technicalAck,
        eancomS3,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Convert EDIFACT files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be translated and validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      eancomS3?: boolean,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<EdifactInterchange>> {
      const localVarFetchArgs = EdifactApiFetchParamCreator(
        configuration
      ).edifactReadPost(
        body,
        fileName,
        ignoreNullValues,
        continueOnError,
        charSet,
        model,
        eancomS3,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Validate EDIFACT messages
     * @param {EdifactInterchange} [body] The EdifactInterchange object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than UNOA and UNOB, populate this filed with all of the allowed symbols, url-escaped.              All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The supported syntax sets are UNOA and UNOB. The validator infers the correct syntax set from EdifactInterchange.UNB.SYNTAXIDENTIFIER_1.SyntaxIdentifier_1. The symbols added to this field will override the corresponding sets in both UNOA and UNOB.
     * @param {boolean} [skipTrailer] You are allowed to validate an EdifactInterchange with missing interchange, functional group or transaction trailers (UNZ, UNE, UNT). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the EdifactInterchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {string} [decimalPoint] This could be either point . (default) or comma ,.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactValidatePost(
      body?: EdifactInterchange,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      decimalPoint?: string,
      eancomS3?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
      const localVarFetchArgs = EdifactApiFetchParamCreator(
        configuration
      ).edifactValidatePost(
        body,
        syntaxSet,
        skipTrailer,
        structureOnly,
        decimalPoint,
        eancomS3,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Convert JSON to EDIFACT files
     * @param {EdifactInterchange} [body] The EdifactInterchange object to translate to raw EDIFACT.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {boolean} [sameRepetionAndDataElement] Sometimes the same delimiter is used to denote data element separator and repetition separator as in IATA transactions. By default, this is false.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be translated and validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactWritePost(
      body?: EdifactInterchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      sameRepetionAndDataElement?: boolean,
      eancomS3?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = EdifactApiFetchParamCreator(
        configuration
      ).edifactWritePost(
        body,
        preserveWhitespace,
        charSet,
        postfix,
        sameRepetionAndDataElement,
        eancomS3,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * EdifactApi - factory interface
 * @export
 */
export const EdifactApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Generate EDIFACT acknowledments
     * @param {EdifactInterchange} [body] The EdifactInterchange object to acknowledge.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than UNOA and UNOB, populate this filed with all of the allowed symbols, url-escaped. All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The supported syntax sets are UNOA and UNOB. The validator infers the correct syntax set from EdifactInterchange.UNB.SYNTAXIDENTIFIER_1.SyntaxIdentifier_1. The symbols added to this field will override the corresponding sets in both UNOA and UNOB.
     * @param {boolean} [detectDuplicates] If you need to detect duplicates as in functional groups or transactions with the same reference number, set this flag to true. The default is false.
     * @param {number} [tranRefNumber] The default is 1. Set this to whatever the CONTRL UNH.MessageReferenceNumber_01 needs to be.
     * @param {number} [interchangeRefNumber] The default is 1. Set this to whatever the CONTRL EdifactInterchange.UNB.InterchangeControlReference_5 needs to be.
     * @param {boolean} [ackForValidTrans] The default is false. Set this to true if you need UCM loops included for all valid transaction as well. By default UCM loops are generated only for invalid transactions.
     * @param {boolean} [batchAcks] The default is true. Set this to false if you need to generate separate EdifactInterchange for each acknowledgment. By default all acknowledgments are batched in the same EdifactInterchange.
     * @param {string} [technicalAck] The default technical acknowledgment CONTRL is generated according to EdifactInterchange.UNB.AcknowledgementRequest_9. You can either enforce it to always generate technical CONTRLs or supress it to never generate any technical CONTRLs. This will override the flag in EdifactInterchange.UNB.AcknowledgementRequest_9.              The available values are: default, enforce, suppress.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactAckPost(
      body?: EdifactInterchange,
      syntaxSet?: string,
      detectDuplicates?: boolean,
      tranRefNumber?: number,
      interchangeRefNumber?: number,
      ackForValidTrans?: boolean,
      batchAcks?: boolean,
      technicalAck?: string,
      eancomS3?: boolean,
      options?: any
    ) {
      return EdifactApiFp(configuration).edifactAckPost(
        body,
        syntaxSet,
        detectDuplicates,
        tranRefNumber,
        interchangeRefNumber,
        ackForValidTrans,
        batchAcks,
        technicalAck,
        eancomS3,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Convert EDIFACT files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be translated and validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      eancomS3?: boolean,
      options?: any
    ) {
      return EdifactApiFp(configuration).edifactReadPost(
        body,
        fileName,
        ignoreNullValues,
        continueOnError,
        charSet,
        model,
        eancomS3,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Validate EDIFACT messages
     * @param {EdifactInterchange} [body] The EdifactInterchange object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than UNOA and UNOB, populate this filed with all of the allowed symbols, url-escaped.              All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The supported syntax sets are UNOA and UNOB. The validator infers the correct syntax set from EdifactInterchange.UNB.SYNTAXIDENTIFIER_1.SyntaxIdentifier_1. The symbols added to this field will override the corresponding sets in both UNOA and UNOB.
     * @param {boolean} [skipTrailer] You are allowed to validate an EdifactInterchange with missing interchange, functional group or transaction trailers (UNZ, UNE, UNT). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the EdifactInterchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {string} [decimalPoint] This could be either point . (default) or comma ,.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactValidatePost(
      body?: EdifactInterchange,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      decimalPoint?: string,
      eancomS3?: boolean,
      options?: any
    ) {
      return EdifactApiFp(configuration).edifactValidatePost(
        body,
        syntaxSet,
        skipTrailer,
        structureOnly,
        decimalPoint,
        eancomS3,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Convert JSON to EDIFACT files
     * @param {EdifactInterchange} [body] The EdifactInterchange object to translate to raw EDIFACT.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {boolean} [sameRepetionAndDataElement] Sometimes the same delimiter is used to denote data element separator and repetition separator as in IATA transactions. By default, this is false.
     * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be translated and validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edifactWritePost(
      body?: EdifactInterchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      sameRepetionAndDataElement?: boolean,
      eancomS3?: boolean,
      options?: any
    ) {
      return EdifactApiFp(configuration).edifactWritePost(
        body,
        preserveWhitespace,
        charSet,
        postfix,
        sameRepetionAndDataElement,
        eancomS3,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * EdifactApi - object-oriented interface
 * @export
 * @class EdifactApi
 * @extends {BaseAPI}
 */
export class EdifactApi extends BaseAPI {
  /**
   *
   * @summary Generate EDIFACT acknowledments
   * @param {EdifactInterchange} [body] The EdifactInterchange object to acknowledge.
   * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than UNOA and UNOB, populate this filed with all of the allowed symbols, url-escaped. All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The supported syntax sets are UNOA and UNOB. The validator infers the correct syntax set from EdifactInterchange.UNB.SYNTAXIDENTIFIER_1.SyntaxIdentifier_1. The symbols added to this field will override the corresponding sets in both UNOA and UNOB.
   * @param {boolean} [detectDuplicates] If you need to detect duplicates as in functional groups or transactions with the same reference number, set this flag to true. The default is false.
   * @param {number} [tranRefNumber] The default is 1. Set this to whatever the CONTRL UNH.MessageReferenceNumber_01 needs to be.
   * @param {number} [interchangeRefNumber] The default is 1. Set this to whatever the CONTRL EdifactInterchange.UNB.InterchangeControlReference_5 needs to be.
   * @param {boolean} [ackForValidTrans] The default is false. Set this to true if you need UCM loops included for all valid transaction as well. By default UCM loops are generated only for invalid transactions.
   * @param {boolean} [batchAcks] The default is true. Set this to false if you need to generate separate EdifactInterchange for each acknowledgment. By default all acknowledgments are batched in the same EdifactInterchange.
   * @param {string} [technicalAck] The default technical acknowledgment CONTRL is generated according to EdifactInterchange.UNB.AcknowledgementRequest_9. You can either enforce it to always generate technical CONTRLs or supress it to never generate any technical CONTRLs. This will override the flag in EdifactInterchange.UNB.AcknowledgementRequest_9.              The available values are: default, enforce, suppress.
   * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EdifactApi
   */
  public edifactAckPost(
    body?: EdifactInterchange,
    syntaxSet?: string,
    detectDuplicates?: boolean,
    tranRefNumber?: number,
    interchangeRefNumber?: number,
    ackForValidTrans?: boolean,
    batchAcks?: boolean,
    technicalAck?: string,
    eancomS3?: boolean,
    options?: any
  ) {
    return EdifactApiFp(this.configuration).edifactAckPost(
      body,
      syntaxSet,
      detectDuplicates,
      tranRefNumber,
      interchangeRefNumber,
      ackForValidTrans,
      batchAcks,
      technicalAck,
      eancomS3,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Convert EDIFACT files to JSON
   * @param {Object} [body]
   * @param {Blob} [fileName]
   * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
   * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
   * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be translated and validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EdifactApi
   */
  public edifactReadPost(
    body?: Object,
    fileName?: Blob,
    ignoreNullValues?: boolean,
    continueOnError?: boolean,
    charSet?: string,
    model?: string,
    eancomS3?: boolean,
    options?: any
  ) {
    return EdifactApiFp(this.configuration).edifactReadPost(
      body,
      fileName,
      ignoreNullValues,
      continueOnError,
      charSet,
      model,
      eancomS3,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Validate EDIFACT messages
   * @param {EdifactInterchange} [body] The EdifactInterchange object to validate.
   * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than UNOA and UNOB, populate this filed with all of the allowed symbols, url-escaped.              All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The supported syntax sets are UNOA and UNOB. The validator infers the correct syntax set from EdifactInterchange.UNB.SYNTAXIDENTIFIER_1.SyntaxIdentifier_1. The symbols added to this field will override the corresponding sets in both UNOA and UNOB.
   * @param {boolean} [skipTrailer] You are allowed to validate an EdifactInterchange with missing interchange, functional group or transaction trailers (UNZ, UNE, UNT). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the EdifactInterchange and by default, this is set to false. To skip all trailer validation, set this to true.
   * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
   * @param {string} [decimalPoint] This could be either point . (default) or comma ,.
   * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EdifactApi
   */
  public edifactValidatePost(
    body?: EdifactInterchange,
    syntaxSet?: string,
    skipTrailer?: boolean,
    structureOnly?: boolean,
    decimalPoint?: string,
    eancomS3?: boolean,
    options?: any
  ) {
    return EdifactApiFp(this.configuration).edifactValidatePost(
      body,
      syntaxSet,
      skipTrailer,
      structureOnly,
      decimalPoint,
      eancomS3,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Convert JSON to EDIFACT files
   * @param {EdifactInterchange} [body] The EdifactInterchange object to translate to raw EDIFACT.
   * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
   * @param {boolean} [sameRepetionAndDataElement] Sometimes the same delimiter is used to denote data element separator and repetition separator as in IATA transactions. By default, this is false.
   * @param {boolean} [eancomS3] The default syntax for EANCOM transactions. By default all EANCOM transactions will be translated and validated according to the rules of Syntax 4. Set this flag to true if you need Syntax 3 to be used.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EdifactApi
   */
  public edifactWritePost(
    body?: EdifactInterchange,
    preserveWhitespace?: boolean,
    charSet?: string,
    postfix?: string,
    sameRepetionAndDataElement?: boolean,
    eancomS3?: boolean,
    options?: any
  ) {
    return EdifactApiFp(this.configuration).edifactWritePost(
      body,
      preserveWhitespace,
      charSet,
      postfix,
      sameRepetionAndDataElement,
      eancomS3,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * Hl7Api - fetch parameter creator
 * @export
 */
export const Hl7ApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Convert HL7 files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7ReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/hl7/read`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (ignoreNullValues !== undefined) {
        localVarQueryParameter['ignoreNullValues'] = ignoreNullValues
      }

      if (continueOnError !== undefined) {
        localVarQueryParameter['continueOnError'] = continueOnError
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (model !== undefined) {
        localVarQueryParameter['model'] = model
      }

      if (fileName !== undefined) {
        localVarFormParams.set('fileName', fileName as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Validate HL7 messages
     * @param {Hl7Interchange} [body] The Hl7Interchange object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [skipTrailer] You are allowed to validate an Hl7Interchange with missing file or batch trailers (FTS, BTS). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the X12Interchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7ValidatePost(
      body?: Hl7Interchange,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/hl7/validate`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (syntaxSet !== undefined) {
        localVarQueryParameter['syntaxSet'] = syntaxSet
      }

      if (skipTrailer !== undefined) {
        localVarQueryParameter['skipTrailer'] = skipTrailer
      }

      if (structureOnly !== undefined) {
        localVarQueryParameter['structureOnly'] = structureOnly
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'Hl7Interchange' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Convert JSON to HL7 files
     * @param {Hl7Interchange} [body] The HL7Interchange object to translate to raw HL7.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7WritePost(
      body?: Hl7Interchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/hl7/write`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (preserveWhitespace !== undefined) {
        localVarQueryParameter['preserveWhitespace'] = preserveWhitespace
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (postfix !== undefined) {
        localVarQueryParameter['postfix'] = postfix
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'Hl7Interchange' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * Hl7Api - functional programming interface
 * @export
 */
export const Hl7ApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Convert HL7 files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7ReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Hl7Interchange>> {
      const localVarFetchArgs = Hl7ApiFetchParamCreator(
        configuration
      ).hl7ReadPost(
        body,
        fileName,
        ignoreNullValues,
        continueOnError,
        charSet,
        model,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Validate HL7 messages
     * @param {Hl7Interchange} [body] The Hl7Interchange object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [skipTrailer] You are allowed to validate an Hl7Interchange with missing file or batch trailers (FTS, BTS). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the X12Interchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7ValidatePost(
      body?: Hl7Interchange,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
      const localVarFetchArgs = Hl7ApiFetchParamCreator(
        configuration
      ).hl7ValidatePost(body, syntaxSet, skipTrailer, structureOnly, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Convert JSON to HL7 files
     * @param {Hl7Interchange} [body] The HL7Interchange object to translate to raw HL7.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7WritePost(
      body?: Hl7Interchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = Hl7ApiFetchParamCreator(
        configuration
      ).hl7WritePost(body, preserveWhitespace, charSet, postfix, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * Hl7Api - factory interface
 * @export
 */
export const Hl7ApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Convert HL7 files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7ReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options?: any
    ) {
      return Hl7ApiFp(configuration).hl7ReadPost(
        body,
        fileName,
        ignoreNullValues,
        continueOnError,
        charSet,
        model,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Validate HL7 messages
     * @param {Hl7Interchange} [body] The Hl7Interchange object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [skipTrailer] You are allowed to validate an Hl7Interchange with missing file or batch trailers (FTS, BTS). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the X12Interchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7ValidatePost(
      body?: Hl7Interchange,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      options?: any
    ) {
      return Hl7ApiFp(configuration).hl7ValidatePost(
        body,
        syntaxSet,
        skipTrailer,
        structureOnly,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Convert JSON to HL7 files
     * @param {Hl7Interchange} [body] The HL7Interchange object to translate to raw HL7.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hl7WritePost(
      body?: Hl7Interchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      options?: any
    ) {
      return Hl7ApiFp(configuration).hl7WritePost(
        body,
        preserveWhitespace,
        charSet,
        postfix,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * Hl7Api - object-oriented interface
 * @export
 * @class Hl7Api
 * @extends {BaseAPI}
 */
export class Hl7Api extends BaseAPI {
  /**
   *
   * @summary Convert HL7 files to JSON
   * @param {Object} [body]
   * @param {Blob} [fileName]
   * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
   * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Hl7Api
   */
  public hl7ReadPost(
    body?: Object,
    fileName?: Blob,
    ignoreNullValues?: boolean,
    continueOnError?: boolean,
    charSet?: string,
    model?: string,
    options?: any
  ) {
    return Hl7ApiFp(this.configuration).hl7ReadPost(
      body,
      fileName,
      ignoreNullValues,
      continueOnError,
      charSet,
      model,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Validate HL7 messages
   * @param {Hl7Interchange} [body] The Hl7Interchange object to validate.
   * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
   * @param {boolean} [skipTrailer] You are allowed to validate an Hl7Interchange with missing file or batch trailers (FTS, BTS). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the X12Interchange and by default, this is set to false. To skip all trailer validation, set this to true.
   * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Hl7Api
   */
  public hl7ValidatePost(
    body?: Hl7Interchange,
    syntaxSet?: string,
    skipTrailer?: boolean,
    structureOnly?: boolean,
    options?: any
  ) {
    return Hl7ApiFp(this.configuration).hl7ValidatePost(
      body,
      syntaxSet,
      skipTrailer,
      structureOnly,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Convert JSON to HL7 files
   * @param {Hl7Interchange} [body] The HL7Interchange object to translate to raw HL7.
   * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Hl7Api
   */
  public hl7WritePost(
    body?: Hl7Interchange,
    preserveWhitespace?: boolean,
    charSet?: string,
    postfix?: string,
    options?: any
  ) {
    return Hl7ApiFp(this.configuration).hl7WritePost(
      body,
      preserveWhitespace,
      charSet,
      postfix,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * NcpdpApi - fetch parameter creator
 * @export
 */
export const NcpdpApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Convert NCPDP files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      charSet?: string,
      model?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/ncpdp/read`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (ignoreNullValues !== undefined) {
        localVarQueryParameter['ignoreNullValues'] = ignoreNullValues
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (model !== undefined) {
        localVarQueryParameter['model'] = model
      }

      if (fileName !== undefined) {
        localVarFormParams.set('fileName', fileName as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Validate NCPDP messages
     * @param {NcpdpTransmission} [body] The NcpdpTransmission object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Default, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpValidatePost(
      body?: NcpdpTransmission,
      syntaxSet?: string,
      structureOnly?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/ncpdp/validate`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (syntaxSet !== undefined) {
        localVarQueryParameter['syntaxSet'] = syntaxSet
      }

      if (structureOnly !== undefined) {
        localVarQueryParameter['structureOnly'] = structureOnly
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'NcpdpTransmission' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Convert JSON to NCPDP files
     * @param {NcpdpTransmission} [body] The NcpdpTransmission object to translate to raw NCPDP.
     * @param {boolean} [noG1] Whether to omit the transaction header G1. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [trailerMessage] The optional message in the transmission trailer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpWritePost(
      body?: NcpdpTransmission,
      noG1?: boolean,
      charSet?: string,
      trailerMessage?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/ncpdp/write`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (noG1 !== undefined) {
        localVarQueryParameter['noG1'] = noG1
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (trailerMessage !== undefined) {
        localVarQueryParameter['trailerMessage'] = trailerMessage
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'NcpdpTransmission' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * NcpdpApi - functional programming interface
 * @export
 */
export const NcpdpApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Convert NCPDP files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      charSet?: string,
      model?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<NcpdpTransmission> {
      const localVarFetchArgs = NcpdpApiFetchParamCreator(
        configuration
      ).ncpdpReadPost(body, fileName, ignoreNullValues, charSet, model, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Validate NCPDP messages
     * @param {NcpdpTransmission} [body] The NcpdpTransmission object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Default, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpValidatePost(
      body?: NcpdpTransmission,
      syntaxSet?: string,
      structureOnly?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
      const localVarFetchArgs = NcpdpApiFetchParamCreator(
        configuration
      ).ncpdpValidatePost(body, syntaxSet, structureOnly, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Convert JSON to NCPDP files
     * @param {NcpdpTransmission} [body] The NcpdpTransmission object to translate to raw NCPDP.
     * @param {boolean} [noG1] Whether to omit the transaction header G1. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [trailerMessage] The optional message in the transmission trailer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpWritePost(
      body?: NcpdpTransmission,
      noG1?: boolean,
      charSet?: string,
      trailerMessage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = NcpdpApiFetchParamCreator(
        configuration
      ).ncpdpWritePost(body, noG1, charSet, trailerMessage, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * NcpdpApi - factory interface
 * @export
 */
export const NcpdpApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Convert NCPDP files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      charSet?: string,
      model?: string,
      options?: any
    ) {
      return NcpdpApiFp(configuration).ncpdpReadPost(
        body,
        fileName,
        ignoreNullValues,
        charSet,
        model,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Validate NCPDP messages
     * @param {NcpdpTransmission} [body] The NcpdpTransmission object to validate.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Default, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpValidatePost(
      body?: NcpdpTransmission,
      syntaxSet?: string,
      structureOnly?: boolean,
      options?: any
    ) {
      return NcpdpApiFp(configuration).ncpdpValidatePost(
        body,
        syntaxSet,
        structureOnly,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Convert JSON to NCPDP files
     * @param {NcpdpTransmission} [body] The NcpdpTransmission object to translate to raw NCPDP.
     * @param {boolean} [noG1] Whether to omit the transaction header G1. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [trailerMessage] The optional message in the transmission trailer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ncpdpWritePost(
      body?: NcpdpTransmission,
      noG1?: boolean,
      charSet?: string,
      trailerMessage?: string,
      options?: any
    ) {
      return NcpdpApiFp(configuration).ncpdpWritePost(
        body,
        noG1,
        charSet,
        trailerMessage,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * NcpdpApi - object-oriented interface
 * @export
 * @class NcpdpApi
 * @extends {BaseAPI}
 */
export class NcpdpApi extends BaseAPI {
  /**
   *
   * @summary Convert NCPDP files to JSON
   * @param {Object} [body]
   * @param {Blob} [fileName]
   * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NcpdpApi
   */
  public ncpdpReadPost(
    body?: Object,
    fileName?: Blob,
    ignoreNullValues?: boolean,
    charSet?: string,
    model?: string,
    options?: any
  ) {
    return NcpdpApiFp(this.configuration).ncpdpReadPost(
      body,
      fileName,
      ignoreNullValues,
      charSet,
      model,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Validate NCPDP messages
   * @param {NcpdpTransmission} [body] The NcpdpTransmission object to validate.
   * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Default, populate this filed with all of the allowed symbols, url-escaped.
   * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NcpdpApi
   */
  public ncpdpValidatePost(
    body?: NcpdpTransmission,
    syntaxSet?: string,
    structureOnly?: boolean,
    options?: any
  ) {
    return NcpdpApiFp(this.configuration).ncpdpValidatePost(
      body,
      syntaxSet,
      structureOnly,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Convert JSON to NCPDP files
   * @param {NcpdpTransmission} [body] The NcpdpTransmission object to translate to raw NCPDP.
   * @param {boolean} [noG1] Whether to omit the transaction header G1. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [trailerMessage] The optional message in the transmission trailer.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NcpdpApi
   */
  public ncpdpWritePost(
    body?: NcpdpTransmission,
    noG1?: boolean,
    charSet?: string,
    trailerMessage?: string,
    options?: any
  ) {
    return NcpdpApiFp(this.configuration).ncpdpWritePost(
      body,
      noG1,
      charSet,
      trailerMessage,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * VdaApi - fetch parameter creator
 * @export
 */
export const VdaApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Convert VDA files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/vda/read`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (ignoreNullValues !== undefined) {
        localVarQueryParameter['ignoreNullValues'] = ignoreNullValues
      }

      if (continueOnError !== undefined) {
        localVarQueryParameter['continueOnError'] = continueOnError
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (model !== undefined) {
        localVarQueryParameter['model'] = model
      }

      if (fileName !== undefined) {
        localVarFormParams.set('fileName', fileName as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Validate VDA messages
     * @param {FlatMessage} [body] The VDA object to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaValidatePost(body?: FlatMessage, options: any = {}): FetchArgs {
      const localVarPath = `/vda/validate`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'FlatMessage' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Convert JSON to VDA files
     * @param {FlatMessage} [body] The VDA object to translate to raw VDA.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaWritePost(
      body?: FlatMessage,
      charSet?: string,
      postfix?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/vda/write`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (postfix !== undefined) {
        localVarQueryParameter['postfix'] = postfix
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'FlatMessage' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * VdaApi - functional programming interface
 * @export
 */
export const VdaApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Convert VDA files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FlatMessage>> {
      const localVarFetchArgs = VdaApiFetchParamCreator(
        configuration
      ).vdaReadPost(
        body,
        fileName,
        ignoreNullValues,
        continueOnError,
        charSet,
        model,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Validate VDA messages
     * @param {FlatMessage} [body] The VDA object to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaValidatePost(
      body?: FlatMessage,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
      const localVarFetchArgs = VdaApiFetchParamCreator(
        configuration
      ).vdaValidatePost(body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Convert JSON to VDA files
     * @param {FlatMessage} [body] The VDA object to translate to raw VDA.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaWritePost(
      body?: FlatMessage,
      charSet?: string,
      postfix?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = VdaApiFetchParamCreator(
        configuration
      ).vdaWritePost(body, charSet, postfix, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * VdaApi - factory interface
 * @export
 */
export const VdaApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Convert VDA files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options?: any
    ) {
      return VdaApiFp(configuration).vdaReadPost(
        body,
        fileName,
        ignoreNullValues,
        continueOnError,
        charSet,
        model,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Validate VDA messages
     * @param {FlatMessage} [body] The VDA object to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaValidatePost(body?: FlatMessage, options?: any) {
      return VdaApiFp(configuration).vdaValidatePost(body, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Convert JSON to VDA files
     * @param {FlatMessage} [body] The VDA object to translate to raw VDA.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vdaWritePost(
      body?: FlatMessage,
      charSet?: string,
      postfix?: string,
      options?: any
    ) {
      return VdaApiFp(configuration).vdaWritePost(
        body,
        charSet,
        postfix,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * VdaApi - object-oriented interface
 * @export
 * @class VdaApi
 * @extends {BaseAPI}
 */
export class VdaApi extends BaseAPI {
  /**
   *
   * @summary Convert VDA files to JSON
   * @param {Object} [body]
   * @param {Blob} [fileName]
   * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
   * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VdaApi
   */
  public vdaReadPost(
    body?: Object,
    fileName?: Blob,
    ignoreNullValues?: boolean,
    continueOnError?: boolean,
    charSet?: string,
    model?: string,
    options?: any
  ) {
    return VdaApiFp(this.configuration).vdaReadPost(
      body,
      fileName,
      ignoreNullValues,
      continueOnError,
      charSet,
      model,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Validate VDA messages
   * @param {FlatMessage} [body] The VDA object to validate.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VdaApi
   */
  public vdaValidatePost(body?: FlatMessage, options?: any) {
    return VdaApiFp(this.configuration).vdaValidatePost(body, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Convert JSON to VDA files
   * @param {FlatMessage} [body] The VDA object to translate to raw VDA.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VdaApi
   */
  public vdaWritePost(
    body?: FlatMessage,
    charSet?: string,
    postfix?: string,
    options?: any
  ) {
    return VdaApiFp(this.configuration).vdaWritePost(
      body,
      charSet,
      postfix,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * X12Api - fetch parameter creator
 * @export
 */
export const X12ApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Generate X12 acknowledments
     * @param {X12Interchange} [body] The X12Interchange object to acknowledge.
     * @param {boolean} [basicSyntax] All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The default syntax set is the Extended, hence the default for this parameter is false. By setting this to true, validation will use the Basic syntax set.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [detectDuplicates] If you need to detect duplicates as in functional groups or transactions with the same reference number, set this flag to true. The default is false.
     * @param {number} [tranRefNumber] The default is 1. Set this to whatever the 997 or 999 X12Interchange.ST.TransactionSetControlNumber_02 needs to be. In case there are multiple acknowledgments (for multiple functional groups), this will be starting reference number and every subsequent acknowledgment will have the previous reference number incremented with 1.
     * @param {number} [interchangeRefNumber] The default is 1. Set this to whatever the 997 or 999 X12Interchange.ISA.InterchangeControlNumber_13 needs to be.
     * @param {boolean} [ackForValidTrans] The default is false. Set this to true if you need AK2 loops included for all valid transaction as well. By default AK2 loops are generated only for invalid transactions.
     * @param {boolean} [batchAcks] The default is true. Set this to false if you need to generate separate X12Interchange for each acknowledgment. By default all acknowledgments are batched in the same X12Interchange.
     * @param {string} [technicalAck] The default technical acknowledgment TA1 is generated according to X12Interchange.ISA.AcknowledgementRequested_14. You can either enforce it to always generate TA1s or supress it to never generate any TA1s. This will override the flag in X12Interchange.ISA.AcknowledgementRequested_14.              The available values are: default, enforce, suppress.
     * @param {string} [ack] The default value is 997. The type of acknowledgment being generated. Set this to 999 if you need to generate an implementation instead of functional acknowledgment. The available values are: 997, 999.
     * @param {boolean} [ak901isP] The value of the AK9&#x27;s first element. By default it is \&quot;E\&quot;. Set this to true if you want this value to be \&quot;P\&quot; instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12AckPost(
      body?: X12Interchange,
      basicSyntax?: boolean,
      syntaxSet?: string,
      detectDuplicates?: boolean,
      tranRefNumber?: number,
      interchangeRefNumber?: number,
      ackForValidTrans?: boolean,
      batchAcks?: boolean,
      technicalAck?: string,
      ack?: string,
      ak901isP?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/x12/ack`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (basicSyntax !== undefined) {
        localVarQueryParameter['basicSyntax'] = basicSyntax
      }

      if (syntaxSet !== undefined) {
        localVarQueryParameter['syntaxSet'] = syntaxSet
      }

      if (detectDuplicates !== undefined) {
        localVarQueryParameter['detectDuplicates'] = detectDuplicates
      }

      if (tranRefNumber !== undefined) {
        localVarQueryParameter['tranRefNumber'] = tranRefNumber
      }

      if (interchangeRefNumber !== undefined) {
        localVarQueryParameter['interchangeRefNumber'] = interchangeRefNumber
      }

      if (ackForValidTrans !== undefined) {
        localVarQueryParameter['ackForValidTrans'] = ackForValidTrans
      }

      if (batchAcks !== undefined) {
        localVarQueryParameter['batchAcks'] = batchAcks
      }

      if (technicalAck !== undefined) {
        localVarQueryParameter['technicalAck'] = technicalAck
      }

      if (ack !== undefined) {
        localVarQueryParameter['ack'] = ack
      }

      if (ak901isP !== undefined) {
        localVarQueryParameter['ak901isP'] = ak901isP
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'X12Interchange' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Convert X12 files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12ReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/x12/read`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (ignoreNullValues !== undefined) {
        localVarQueryParameter['ignoreNullValues'] = ignoreNullValues
      }

      if (continueOnError !== undefined) {
        localVarQueryParameter['continueOnError'] = continueOnError
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (model !== undefined) {
        localVarQueryParameter['model'] = model
      }

      if (fileName !== undefined) {
        localVarFormParams.set('fileName', fileName as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Validate X12 messages
     * @param {X12Interchange} [body] The X12Interchange object to validate.
     * @param {boolean} [basicSyntax] All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The default syntax set is the Extended, hence the default for this parameter is false. By setting this to true, validation will use the Basic syntax set.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [skipTrailer] You are allowed to validate an X12Interchange with missing interchange, functional group or transaction trailers (IEA, GE, SE). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the X12Interchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12ValidatePost(
      body?: X12Interchange,
      basicSyntax?: boolean,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/x12/validate`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (basicSyntax !== undefined) {
        localVarQueryParameter['basicSyntax'] = basicSyntax
      }

      if (syntaxSet !== undefined) {
        localVarQueryParameter['syntaxSet'] = syntaxSet
      }

      if (skipTrailer !== undefined) {
        localVarQueryParameter['skipTrailer'] = skipTrailer
      }

      if (structureOnly !== undefined) {
        localVarQueryParameter['structureOnly'] = structureOnly
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'X12Interchange' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Convert JSON to X12 files
     * @param {X12Interchange} [body] The X12Interchange object to translate to raw X12.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12WritePost(
      body?: X12Interchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/x12/write`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ApiKey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Ocp-Apim-Subscription-Key')
            : configuration.apiKey
        localVarHeaderParameter['Ocp-Apim-Subscription-Key'] =
          localVarApiKeyValue
      }

      if (preserveWhitespace !== undefined) {
        localVarQueryParameter['preserveWhitespace'] = preserveWhitespace
      }

      if (charSet !== undefined) {
        localVarQueryParameter['charSet'] = charSet
      }

      if (postfix !== undefined) {
        localVarQueryParameter['postfix'] = postfix
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'X12Interchange' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * X12Api - functional programming interface
 * @export
 */
export const X12ApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Generate X12 acknowledments
     * @param {X12Interchange} [body] The X12Interchange object to acknowledge.
     * @param {boolean} [basicSyntax] All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The default syntax set is the Extended, hence the default for this parameter is false. By setting this to true, validation will use the Basic syntax set.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [detectDuplicates] If you need to detect duplicates as in functional groups or transactions with the same reference number, set this flag to true. The default is false.
     * @param {number} [tranRefNumber] The default is 1. Set this to whatever the 997 or 999 X12Interchange.ST.TransactionSetControlNumber_02 needs to be. In case there are multiple acknowledgments (for multiple functional groups), this will be starting reference number and every subsequent acknowledgment will have the previous reference number incremented with 1.
     * @param {number} [interchangeRefNumber] The default is 1. Set this to whatever the 997 or 999 X12Interchange.ISA.InterchangeControlNumber_13 needs to be.
     * @param {boolean} [ackForValidTrans] The default is false. Set this to true if you need AK2 loops included for all valid transaction as well. By default AK2 loops are generated only for invalid transactions.
     * @param {boolean} [batchAcks] The default is true. Set this to false if you need to generate separate X12Interchange for each acknowledgment. By default all acknowledgments are batched in the same X12Interchange.
     * @param {string} [technicalAck] The default technical acknowledgment TA1 is generated according to X12Interchange.ISA.AcknowledgementRequested_14. You can either enforce it to always generate TA1s or supress it to never generate any TA1s. This will override the flag in X12Interchange.ISA.AcknowledgementRequested_14.              The available values are: default, enforce, suppress.
     * @param {string} [ack] The default value is 997. The type of acknowledgment being generated. Set this to 999 if you need to generate an implementation instead of functional acknowledgment. The available values are: 997, 999.
     * @param {boolean} [ak901isP] The value of the AK9&#x27;s first element. By default it is \&quot;E\&quot;. Set this to true if you want this value to be \&quot;P\&quot; instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12AckPost(
      body?: X12Interchange,
      basicSyntax?: boolean,
      syntaxSet?: string,
      detectDuplicates?: boolean,
      tranRefNumber?: number,
      interchangeRefNumber?: number,
      ackForValidTrans?: boolean,
      batchAcks?: boolean,
      technicalAck?: string,
      ack?: string,
      ak901isP?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<X12Interchange>> {
      const localVarFetchArgs = X12ApiFetchParamCreator(
        configuration
      ).x12AckPost(
        body,
        basicSyntax,
        syntaxSet,
        detectDuplicates,
        tranRefNumber,
        interchangeRefNumber,
        ackForValidTrans,
        batchAcks,
        technicalAck,
        ack,
        ak901isP,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Convert X12 files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12ReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<X12Interchange>> {
      const localVarFetchArgs = X12ApiFetchParamCreator(
        configuration
      ).x12ReadPost(
        body,
        fileName,
        ignoreNullValues,
        continueOnError,
        charSet,
        model,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Validate X12 messages
     * @param {X12Interchange} [body] The X12Interchange object to validate.
     * @param {boolean} [basicSyntax] All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The default syntax set is the Extended, hence the default for this parameter is false. By setting this to true, validation will use the Basic syntax set.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [skipTrailer] You are allowed to validate an X12Interchange with missing interchange, functional group or transaction trailers (IEA, GE, SE). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the X12Interchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12ValidatePost(
      body?: X12Interchange,
      basicSyntax?: boolean,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
      const localVarFetchArgs = X12ApiFetchParamCreator(
        configuration
      ).x12ValidatePost(
        body,
        basicSyntax,
        syntaxSet,
        skipTrailer,
        structureOnly,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Convert JSON to X12 files
     * @param {X12Interchange} [body] The X12Interchange object to translate to raw X12.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12WritePost(
      body?: X12Interchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = X12ApiFetchParamCreator(
        configuration
      ).x12WritePost(body, preserveWhitespace, charSet, postfix, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * X12Api - factory interface
 * @export
 */
export const X12ApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Generate X12 acknowledments
     * @param {X12Interchange} [body] The X12Interchange object to acknowledge.
     * @param {boolean} [basicSyntax] All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The default syntax set is the Extended, hence the default for this parameter is false. By setting this to true, validation will use the Basic syntax set.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [detectDuplicates] If you need to detect duplicates as in functional groups or transactions with the same reference number, set this flag to true. The default is false.
     * @param {number} [tranRefNumber] The default is 1. Set this to whatever the 997 or 999 X12Interchange.ST.TransactionSetControlNumber_02 needs to be. In case there are multiple acknowledgments (for multiple functional groups), this will be starting reference number and every subsequent acknowledgment will have the previous reference number incremented with 1.
     * @param {number} [interchangeRefNumber] The default is 1. Set this to whatever the 997 or 999 X12Interchange.ISA.InterchangeControlNumber_13 needs to be.
     * @param {boolean} [ackForValidTrans] The default is false. Set this to true if you need AK2 loops included for all valid transaction as well. By default AK2 loops are generated only for invalid transactions.
     * @param {boolean} [batchAcks] The default is true. Set this to false if you need to generate separate X12Interchange for each acknowledgment. By default all acknowledgments are batched in the same X12Interchange.
     * @param {string} [technicalAck] The default technical acknowledgment TA1 is generated according to X12Interchange.ISA.AcknowledgementRequested_14. You can either enforce it to always generate TA1s or supress it to never generate any TA1s. This will override the flag in X12Interchange.ISA.AcknowledgementRequested_14.              The available values are: default, enforce, suppress.
     * @param {string} [ack] The default value is 997. The type of acknowledgment being generated. Set this to 999 if you need to generate an implementation instead of functional acknowledgment. The available values are: 997, 999.
     * @param {boolean} [ak901isP] The value of the AK9&#x27;s first element. By default it is \&quot;E\&quot;. Set this to true if you want this value to be \&quot;P\&quot; instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12AckPost(
      body?: X12Interchange,
      basicSyntax?: boolean,
      syntaxSet?: string,
      detectDuplicates?: boolean,
      tranRefNumber?: number,
      interchangeRefNumber?: number,
      ackForValidTrans?: boolean,
      batchAcks?: boolean,
      technicalAck?: string,
      ack?: string,
      ak901isP?: boolean,
      options?: any
    ) {
      return X12ApiFp(configuration).x12AckPost(
        body,
        basicSyntax,
        syntaxSet,
        detectDuplicates,
        tranRefNumber,
        interchangeRefNumber,
        ackForValidTrans,
        batchAcks,
        technicalAck,
        ack,
        ak901isP,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Convert X12 files to JSON
     * @param {Object} [body]
     * @param {Blob} [fileName]
     * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
     * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12ReadPost(
      body?: Object,
      fileName?: Blob,
      ignoreNullValues?: boolean,
      continueOnError?: boolean,
      charSet?: string,
      model?: string,
      options?: any
    ) {
      return X12ApiFp(configuration).x12ReadPost(
        body,
        fileName,
        ignoreNullValues,
        continueOnError,
        charSet,
        model,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Validate X12 messages
     * @param {X12Interchange} [body] The X12Interchange object to validate.
     * @param {boolean} [basicSyntax] All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The default syntax set is the Extended, hence the default for this parameter is false. By setting this to true, validation will use the Basic syntax set.
     * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
     * @param {boolean} [skipTrailer] You are allowed to validate an X12Interchange with missing interchange, functional group or transaction trailers (IEA, GE, SE). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the X12Interchange and by default, this is set to false. To skip all trailer validation, set this to true.
     * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12ValidatePost(
      body?: X12Interchange,
      basicSyntax?: boolean,
      syntaxSet?: string,
      skipTrailer?: boolean,
      structureOnly?: boolean,
      options?: any
    ) {
      return X12ApiFp(configuration).x12ValidatePost(
        body,
        basicSyntax,
        syntaxSet,
        skipTrailer,
        structureOnly,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Convert JSON to X12 files
     * @param {X12Interchange} [body] The X12Interchange object to translate to raw X12.
     * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
     * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
     * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    x12WritePost(
      body?: X12Interchange,
      preserveWhitespace?: boolean,
      charSet?: string,
      postfix?: string,
      options?: any
    ) {
      return X12ApiFp(configuration).x12WritePost(
        body,
        preserveWhitespace,
        charSet,
        postfix,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * X12Api - object-oriented interface
 * @export
 * @class X12Api
 * @extends {BaseAPI}
 */
export class X12Api extends BaseAPI {
  /**
   *
   * @summary Generate X12 acknowledments
   * @param {X12Interchange} [body] The X12Interchange object to acknowledge.
   * @param {boolean} [basicSyntax] All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The default syntax set is the Extended, hence the default for this parameter is false. By setting this to true, validation will use the Basic syntax set.
   * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
   * @param {boolean} [detectDuplicates] If you need to detect duplicates as in functional groups or transactions with the same reference number, set this flag to true. The default is false.
   * @param {number} [tranRefNumber] The default is 1. Set this to whatever the 997 or 999 X12Interchange.ST.TransactionSetControlNumber_02 needs to be. In case there are multiple acknowledgments (for multiple functional groups), this will be starting reference number and every subsequent acknowledgment will have the previous reference number incremented with 1.
   * @param {number} [interchangeRefNumber] The default is 1. Set this to whatever the 997 or 999 X12Interchange.ISA.InterchangeControlNumber_13 needs to be.
   * @param {boolean} [ackForValidTrans] The default is false. Set this to true if you need AK2 loops included for all valid transaction as well. By default AK2 loops are generated only for invalid transactions.
   * @param {boolean} [batchAcks] The default is true. Set this to false if you need to generate separate X12Interchange for each acknowledgment. By default all acknowledgments are batched in the same X12Interchange.
   * @param {string} [technicalAck] The default technical acknowledgment TA1 is generated according to X12Interchange.ISA.AcknowledgementRequested_14. You can either enforce it to always generate TA1s or supress it to never generate any TA1s. This will override the flag in X12Interchange.ISA.AcknowledgementRequested_14.              The available values are: default, enforce, suppress.
   * @param {string} [ack] The default value is 997. The type of acknowledgment being generated. Set this to 999 if you need to generate an implementation instead of functional acknowledgment. The available values are: 997, 999.
   * @param {boolean} [ak901isP] The value of the AK9&#x27;s first element. By default it is \&quot;E\&quot;. Set this to true if you want this value to be \&quot;P\&quot; instead.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof X12Api
   */
  public x12AckPost(
    body?: X12Interchange,
    basicSyntax?: boolean,
    syntaxSet?: string,
    detectDuplicates?: boolean,
    tranRefNumber?: number,
    interchangeRefNumber?: number,
    ackForValidTrans?: boolean,
    batchAcks?: boolean,
    technicalAck?: string,
    ack?: string,
    ak901isP?: boolean,
    options?: any
  ) {
    return X12ApiFp(this.configuration).x12AckPost(
      body,
      basicSyntax,
      syntaxSet,
      detectDuplicates,
      tranRefNumber,
      interchangeRefNumber,
      ackForValidTrans,
      batchAcks,
      technicalAck,
      ack,
      ak901isP,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Convert X12 files to JSON
   * @param {Object} [body]
   * @param {Blob} [fileName]
   * @param {boolean} [ignoreNullValues] Whether to ignore all null values in the response. The default is false.
   * @param {boolean} [continueOnError] Whether to continue reading if a corrupt interchange is encountered. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [model] The model to use. By default, the API will infer the model based on the transaction and version identifiers.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof X12Api
   */
  public x12ReadPost(
    body?: Object,
    fileName?: Blob,
    ignoreNullValues?: boolean,
    continueOnError?: boolean,
    charSet?: string,
    model?: string,
    options?: any
  ) {
    return X12ApiFp(this.configuration).x12ReadPost(
      body,
      fileName,
      ignoreNullValues,
      continueOnError,
      charSet,
      model,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Validate X12 messages
   * @param {X12Interchange} [body] The X12Interchange object to validate.
   * @param {boolean} [basicSyntax] All data elements with alpha (A) or alphanumeric (AN) data types are validated against a syntax set of allowed characters. The default syntax set is the Extended, hence the default for this parameter is false. By setting this to true, validation will use the Basic syntax set.
   * @param {string} [syntaxSet] In case you need to validate against a syntax set, different than Basic and Extended, populate this filed with all of the allowed symbols, url-escaped.
   * @param {boolean} [skipTrailer] You are allowed to validate an X12Interchange with missing interchange, functional group or transaction trailers (IEA, GE, SE). This is because these will be automatically applied during the Write oprtaion so you don&#x27;t have to worry about counting the items. By default it is expected that all trailers are present when you validate the X12Interchange and by default, this is set to false. To skip all trailer validation, set this to true.
   * @param {boolean} [structureOnly] This is equivalent to HIPAA Snip level 1, where only the structure and control segments are validated. By default, this is set to false, however if you want to not validate things such as data types, number of repeteitions or dates, set this to true.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof X12Api
   */
  public x12ValidatePost(
    body?: X12Interchange,
    basicSyntax?: boolean,
    syntaxSet?: string,
    skipTrailer?: boolean,
    structureOnly?: boolean,
    options?: any
  ) {
    return X12ApiFp(this.configuration).x12ValidatePost(
      body,
      basicSyntax,
      syntaxSet,
      skipTrailer,
      structureOnly,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Convert JSON to X12 files
   * @param {X12Interchange} [body] The X12Interchange object to translate to raw X12.
   * @param {boolean} [preserveWhitespace] Whether to preserve blank data elements so the output contains multiple delimiters instead of omitting any excess delimiters. The default is false.
   * @param {string} [charSet] The encoding of the file contents. The default is utf-8. The available values are: unicodeFFFE, utf-32, utf-32BE, us-ascii, iso-8859-1, utf-7, utf-8, utf-16.
   * @param {string} [postfix] The postfix to be applied at the end of each segment, just after the segment separator. This is usually a carriage return (CR), line feed (LF) or both. By default, there is no postfix.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof X12Api
   */
  public x12WritePost(
    body?: X12Interchange,
    preserveWhitespace?: boolean,
    charSet?: string,
    postfix?: string,
    options?: any
  ) {
    return X12ApiFp(this.configuration).x12WritePost(
      body,
      preserveWhitespace,
      charSet,
      postfix,
      options
    )(this.fetch, this.basePath)
  }
}
